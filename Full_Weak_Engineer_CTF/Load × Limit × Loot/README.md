# Load × Limit × Loot

|ジャンル|問題名|作問者|タグ|最終スコア|Solve数|
|---|---|---|---|---|---|
|Crypto|Load × Limit × Loot|chama|Easy|296|58|
## Description(問題文)

Let’s pack the knapsack and go on a picnic.

`tar -zxvf prob.tar.gz`

## Solution
It’s a knapsack cryptosystem.

I made this because I wanted to create a beginner problem that uses LLL. That’s why taking the initials of the words gives LLL.

In this problem, we multiply the public key $A \equiv aw_i \pmod M$ by $x_i$ where $x_i \in$ {$0,1$}, and add them up.
In other words, the ciphertext $C$ is represented as the following subset sum :

$$
C = \sum_{i=1}^{64} A_ix_i
$$

Now, for knapsack cryptosystems, when the density of the subset sum $d < \frac{n}{\log_2 \max{A_i}} < 0.9408\dots$, lattice attacks such as LLL can work.
This time, since $n=64, A_i \simeq 128$, we get $d = \frac{64}{128} = 0.5$, so the above attack should be usable.

```python
from sage.all import *

P = [46370304604399661103510587278608860854, 161470033739550046992102957507284694793, 30543660898063616156789781040944567751, 250664599838920908776562323596516643000, 139374138362514071242477757778171360453, 123592723058786214120596739563194410238, 211661190966175954206312604476025891883, 204127984470558401029942508675826118636, 226485320614749484977835154691419711643, 316359778276308230428825295117172452569, 223595536749391578996034934226276385201, 285194897737688239593933128294126253420, 106767966397120299297689471215328740769, 25599906753022130965000372964020080374, 99461971332517921483061891799425259113, 94027794705920646966871149109862801610, 123296061030051008330943248360079826013, 74854535529342502478954289154224576092, 224885683431821751400008043275824815646, 266096166425088007499970985584050784682, 276003343849704749424463898987980442737, 102681588182470124247526654172102644907, 81066074715052040596846980190467140543, 288564406824785492891304803256068657153, 275777490926285666099408286534129620445, 282517686156702650031304218971561203305, 303283907912734438658673255308488382253, 207124905215590627556917580593810100294, 280558080079068849809690254471376167991, 160954151682440634237745640217189791793, 97767119790212416603441928990664031378, 338144640821518318947395128924719917222, 175619923321070422554784972534849507595, 254564156262627389965162628894875365269, 196177539698888734927195275991945056566, 316218059699388548025737940688917830572, 268400154682066693679616423870021647142, 215171060317966594124409556912523500752, 260057877459608494186977306109025707665, 190102548117865681721849886759598482779, 252725419899497668403547022908880618059, 327335827827878566866970242836185642452, 188260325012018828319115719433455849371, 88483421141682536040965596554472029136, 310248075203863607523992695030757874632, 295640402932812162029270725799625344492, 70276872614365224915426973058582085536, 256094493760578638941104549543294911438, 42841363734929118457515014374580961350, 128080761902152925446804036416229034376, 180236556373329949311891716497015905345, 109842713274004118912686485592449650056, 193653151004110836304303931934828586594, 217480566371177947463788535587066608900, 85737645843034151047932615174569760367, 75130577098367771493769881166880018519, 44108879264846109022147939103515256917, 200510426260508215019844361235980313468, 57239393388118598756306963809052694810, 285120374875743578681171629134755246113, 310860836570193120117077183155691495035, 251862421155813445159906426270135772925, 301796605933628926886822581638474528587, 338556933792869391731776683003533084480]
C = [6431903975558659411995736450941742463678, 6798319334988101743518674132084696585109, 6515613864583459558948036293342639545155, 7773122108332461536899295384273685725884, 7116134977799359563372944976071555756181, 6933621053828258679307411351393495758849]

def density(a):
    return RR(len(a)) / RR(Integer(max(a)).nbits())

def bits_to_bytes_be(bits):
    assert len(bits) % 8 == 0
    out = []
    for i in range(0, len(bits), 8):
        b = 0
        for k in range(8):
            b = (b << 1) | int(bits[i+k])
        out.append(b)
    return bytes(out)

def solve_subset_sum_lll(a, S, max_rows=100, use_bkz=True):
    n = len(a)
    bitlen = Integer(max(a)).nbits()

    for delta in [-2, -1, 0, 1, 2, 3, 4]:
        Q = Integer(1) << (bitlen + delta)

        B = Matrix(ZZ, n+1, n+1)
        for i in range(n):
            B[i, i]   = 2
            B[i, n]   = Q * a[i]
        for i in range(n):
            B[n, i]   = 1
        B[n, n]       = Q * S

        R = B.LLL()

        for r in range(min(max_rows, R.nrows())):
            v = vector(R.row(r))
            if v[-1] != 0:
                continue
            if not all(abs(int(v[i])) == 1 for i in range(n)):
                continue
            bits = [ (1 - int(v[i])) // 2 for i in range(n) ]
            if sum(int(ai)*bi for ai, bi in zip(a, bits)) == S:
                return bits

    raise RuntimeError("No short vectors found in LLL.")

print(f"density = {density(P):.6f}  (< 0.94 OK)")
msg = b""
for j, S in enumerate(C):
    bits = solve_subset_sum_lll(P, S)
    block = bits_to_bytes_be(bits)
    msg += block
    print(f"[block {j}] OK  ({len(bits)} bits)")
text = msg.decode("utf-8")

print("Recovered:", text)
```

## Flag

`fwectf{Hey!_This_pr0bl3m_c4n_b3_s0lv3d_w1th_LLL}`

